/* ------------------------------------------------------------------------- */
/*
  Title: MLP3_2001, Neural Network execution code.
  Automatically generated by SNN, Thu Apr 18 20:44:19 2013


  License Agreement:
   -----------------

  Copyright StatSoft Inc., 2000-2001, all rights reserved.
  This source code (Source Code Generated by STATISTICA Neural Networks,
  referred to as 'CG' below) is owned by StatSoft Inc. and is protected
  by United States Copyright laws and international treaty provisions. You
  shall treat the CG like any copyrighted material.
  The CG may not be redistributed or used except in accordance with the
  conditions below.

  The licensee is granted a license to incorporate the CG as embedded
  software in their own hardware and software products, and to distribute an
  unlimited number of such embedded copies as part of this license subject to
  obtaining prior written consent from StatSoft Inc., and subject to
  the conditions listed below.

  Prior consent is required so that StatSoft Inc. can ensure that license
  conditions are not breached, and can track legitimate use of the CG. Consent
  shall not be refused unless StatSoft Inc. reasonably believes that a
  breach of license conditions will occur. Consent shall usually be granted
  within five working days of the request, providing that sufficient details of
  the intended use are given.

  Requests should be sent to SNN Project Director, StatSoft, Inc.,
  2300 East 14th Street, Tulsa OK 74104 USA, FAX: 918-749-2217,
  E-Mail: info@statsoft.com.

  The licensee may modify the CG as they see fit for embedded use, including
  recoding into alternative programming languages, altering the neural network
  architecture and weights, and otherwise modifying the CG, provided that they
  keep intact this copyright and license notice.

  The licensee may distribute products including the compiled version of CG.

  The licensee shall not:-
    Sublicense, rent, lease, or assign any portion of the CG to third parties.
    Allow compiled versions of the CG to be incorporated in products owned
    by third parties.
    Allow access to the CG to third parties.
    Use (implicitly or explicitly) any reference to StatSoft, Inc., STATISTICA,
    STATISTICA Neural Networks, or any trade names used by StatSoft, Inc.
    to describe, promote, or reference products in which CG is used, or which
    benefit from CG.

  Except as expressly stated herein, the CG is provided 'AS IS.' The licensee
  shall be entirely responsible for the selection of the CG and for the
  installation, integration, use of, and results obtained from, the CG.
  In particular, but without limitation, attention is drawn to the issue of
  'limited numeric accuracy,' which implies that results may not be identical to
  those when executing the same network in STATISTICA Neural Networks or through
  its Application Programming Interface.

  All other warranties or conditions, either express or implied, including but
  not limited to implied warranties of merchantability or fitness for a
  particular purpose, with respect to the CG and written information
  accompanying the CG, are excluded from the license.

  No liability for Consequential Damages. To the maximum extent permitted by
  applicable law, in no event shall StatSoft Inc.,
  or the vendor be liable for any damages whatsoever
  (including, without limitation, damages for loss of profits,
  business interruption, loss of information, or any other pecuniary loss)
  arising out of the use or inability to use this product,
  even if the vendor has been advised of the possibility of
  such damages.

  This license and your right to use the CG shall terminate automatically
  if StatSoft, Inc. determines that you violate any part of the agreement
  or if you violate any part of this agreement without the knowledge of
  StatSoft, Inc. In the event of termination, you shall immediately destroy
  all copies of the CG.

  This agreement constitutes the entire agreement between you and StatSoft Inc.,
  and supersedes any prior agreement concerning the CG. It shall
  not be modified except by written agreement dated subsequent to the date of
  this agreement signed by an authorized representative of StatSoft Inc.
  StatSoft Inc. shall not be bound by any provision of any purchase order,
  confirmation, correspondence, or otherwise, unless StatSoft Inc.
  specifically agrees to the provision in writing.

  This agreement shall be considered as a contract made in the United States
  of America and according to United States Law,
  subject to the exclusive jurisdiction of the United States Courts.
*/

/* standard includes. math.h needed for exp() function. */

#include <stdio.h>
#include <math.h>
#include <string.h>
#include <stdlib.h>

#ifndef FALSE
#define FALSE 0
#define TRUE 1
#endif

#define MENUCODE -999


static double MLP3_2001100Thresholds[] =
{

/* layer 1 */
1.2624629098872202, 3.9199791954089784,

/* layer 2 */
2.2056825376706826

};

static double MLP3_2001100Weights[] =
{

/* layer 1 */
1.0017849091378206, 0.69097813730429114, -1.023270892468102, -1.1064470446141779,
0.77096430299591012, 1.4027255114199531, 3.0189806328859792,
0.78942430423143362, 2.0193220047405513, -0.3970727002842992, 0.61131867109517857,
3.1500068565003732, 6.4693063681280885, -1.530406414470288,

/* layer 2 */
2.4258021368737261, 3.5453528163818011

};

static double MLP3_2001100Acts[20];

/* ---------------------------------------------------------- */
/*
  MLP3_2001100Run - run neural network MLP3_2001100

  Input and Output variables.
  Variable names are listed below in order, together with each
  variable's offset in the data set at the time code was
  generated (if the variable is then available).
  For nominal variables, the numeric code - class name
  conversion is shown indented below the variable name.
  To provide nominal inputs, use the corresponding numeric code.
  Input variables (Offset):
  UZAO
  UKOM
  NKON
  PRMA
  WFIB
  SZSP
  SZZA

  Wyjœcie:
  Stan
    1=bankrut
    2=nie bankrut

*/
/* ---------------------------------------------------------- */

void MLP3_2001100Run( double inputs[], double outputs[], int outputType )
{
  int i, j, k, u;
  double *w = MLP3_2001100Weights, *t = MLP3_2001100Thresholds;

  /* Process inputs - apply pre-processing to each input in turn,
   * storing results in the neuron activations array.
   */

  /* Input 0: standard numeric pre-processing: linear shift and scale. */
  if ( inputs[0] == -9999 )
    MLP3_2001100Acts[0] = 0.15935293913886869;
  else
    MLP3_2001100Acts[0] = inputs[0] * 0.010391769718383041 + 0;

  /* Input 1: standard numeric pre-processing: linear shift and scale. */
  if ( inputs[1] == -9999 )
    MLP3_2001100Acts[1] = 0.89002032520325203;
  else
    MLP3_2001100Acts[1] = inputs[1] * 0.07621951219512195 + 0.93445121951219512;

  /* Input 2: standard numeric pre-processing: linear shift and scale. */
  if ( inputs[2] == -9999 )
    MLP3_2001100Acts[2] = 0.20247747747747749;
  else
    MLP3_2001100Acts[2] = inputs[2] * 0.0563063063063063 + 0.14189189189189189;

  /* Input 3: standard numeric pre-processing: linear shift and scale. */
  if ( inputs[3] == -9999 )
    MLP3_2001100Acts[3] = 0.11562668723486311;
  else
    MLP3_2001100Acts[3] = inputs[3] * 0.038565368299267259 + -0.00038565368299267258;

  /* Input 4: standard numeric pre-processing: linear shift and scale. */
  if ( inputs[4] == -9999 )
    MLP3_2001100Acts[4] = 0.55112959112959115;
  else
    MLP3_2001100Acts[4] = inputs[4] * 0.20790020790020788 + 0.5571725571725572;

  /* Input 5: standard numeric pre-processing: linear shift and scale. */
  if ( inputs[5] == -9999 )
    MLP3_2001100Acts[5] = 0.1414022578728461;
  else
    MLP3_2001100Acts[5] = inputs[5] * 0.17825311942959002 + 0.17825311942959002;

  /* Input 6: standard numeric pre-processing: linear shift and scale. */
  if ( inputs[6] == -9999 )
    MLP3_2001100Acts[6] = 0.35104258443465486;
  else
    MLP3_2001100Acts[6] = inputs[6] * 0.44052863436123346 + 0.44052863436123346;

  /*
   * Process layer 1.
   */

  /* For each unit in turn */
  for ( u=0; u < 2; ++u )
  {
    /*
     * First, calculate post-synaptic potentials, storing
     * these in the MLP3_2001100Acts array.
     */

    /* Initialise hidden unit activation to zero */
    MLP3_2001100Acts[7+u] = 0.0;

    /* Accumulate weighted sum from inputs */
    for ( i=0; i < 7; ++i )
      MLP3_2001100Acts[7+u] += *w++ * MLP3_2001100Acts[0+i];

    /* Subtract threshold */
    MLP3_2001100Acts[7+u] -= *t++;

    /* Now apply the hyperbolic activation function, ( e^x - e^-x ) / ( e^x + e^-x ).
     * Deal with overflow and underflow
     */
    if ( MLP3_2001100Acts[7+u] > 100.0 )
       MLP3_2001100Acts[7+u] = 1.0;
    else if ( MLP3_2001100Acts[7+u] < -100.0 )
      MLP3_2001100Acts[7+u] = -1.0;
    else
    {
      double e1 = exp( MLP3_2001100Acts[7+u] ), e2 = exp( -MLP3_2001100Acts[7+u] );
      MLP3_2001100Acts[7+u] = ( e1 - e2 ) / ( e1 + e2 );
    }
  }

  /*
   * Process layer 2.
   */

  /* For each unit in turn */
  for ( u=0; u < 1; ++u )
  {
    /*
     * First, calculate post-synaptic potentials, storing
     * these in the MLP3_2001100Acts array.
     */

    /* Initialise hidden unit activation to zero */
    MLP3_2001100Acts[9+u] = 0.0;

    /* Accumulate weighted sum from inputs */
    for ( i=0; i < 2; ++i )
      MLP3_2001100Acts[9+u] += *w++ * MLP3_2001100Acts[7+i];

    /* Subtract threshold */
    MLP3_2001100Acts[9+u] -= *t++;

    /* Now apply the logistic activation function, 1 / ( 1 + e^-x ).
     * Deal with overflow and underflow
     */
    if ( MLP3_2001100Acts[9+u] > 100.0 )
       MLP3_2001100Acts[9+u] = 1.0;
    else if ( MLP3_2001100Acts[9+u] < -100.0 )
      MLP3_2001100Acts[9+u] = 0.0;
    else
      MLP3_2001100Acts[9+u] = 1.0 / ( 1.0 + exp( - MLP3_2001100Acts[9+u] ) );
  }

  /* Type of output required - selected by outputType parameter */
  switch ( outputType )
  {
    /* The usual type is to generate the output variables */
    case 0:


      /* Post-process output 0, two-state nominal output */
      if ( MLP3_2001100Acts[9] >= 0.5 )
        outputs[0] = 2.0;
      else
        outputs[0] = 1.0;
      break;

    /* type 1 is activation of output neurons */
    case 1:
      for ( i=0; i < 1; ++i )
        outputs[i] = MLP3_2001100Acts[9+i];
      break;

    /* type 2 is codebook vector of winning node (lowest actn) 1st hidden layer */
    case 2:
      {
        int winner=0;
        for ( i=1; i < 2; ++i )
          if ( MLP3_2001100Acts[7+i] < MLP3_2001100Acts[7+winner] )
            winner=i;

        for ( i=0; i < 7; ++i )
          outputs[i] = MLP3_2001100Weights[7*winner+i];
      }
      break;

    /* type 3 indicates winning node (lowest actn) in 1st hidden layer */
    case 3:
      {
        int winner=0;
        for ( i=1; i < 2; ++i )
          if ( MLP3_2001100Acts[7+i] < MLP3_2001100Acts[7+winner] )
            winner=i;

        outputs[0] = winner;
      }
      break;
  }
}

/*
  Test harness. Compile including this main() procedure, as
  a windows console program or a DOS program, to interactively
  test that the software functions as expected.
*/

int main(int argc, char **argv)
{
  int i, j, outputType=0, noOutputs=1, noSteps=1, showMenu=FALSE;
  double inputs[7], outputs[7];

i=0;

while(argc--)
{
if(i==0) atof(*argv++);
else
inputs[i-1]= atof(*argv++);
++i;
}

    /* Run the neural network */
    MLP3_2001100Run( inputs, outputs, outputType );

for ( i=0; i < noOutputs; ++i )
{
printf( "%g\n", outputs[i] );
}

  return 0;
}
